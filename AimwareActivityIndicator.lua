--Working on aimware
--Part of the code comes from forums and GitHub
--[[
Credit
@Network cache and require --Yukine https://aimware.net/forum/user/366321
@write file --Chicken4676 https://aimware.net/forum/user/17687
]]
--Producers by qi

--region aw api
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
--I only made a little change to make him work for aimware
local entities_GetPlayerResources, entities_FindByClass, entities_GetByIndex, entities_GetLocalPlayer, entities_GetByUserID =
    entities.GetPlayerResources,
    entities.FindByClass,
    entities.GetByIndex,
    entities.GetLocalPlayer,
    entities.GetByUserID
local client_GetLocalPlayerIndex,
    client_ChatSay,
    client_WorldToScreen,
    client_Command,
    client_GetPlayerIndexByUserID,
    client_SetConVar,
    client_GetPlayerInfo,
    client_GetConVar =
    client.GetLocalPlayerIndex,
    client.ChatSay,
    client.WorldToScreen,
    client.Command,
    client.GetPlayerIndexByUserID,
    client.SetConVar,
    client.GetPlayerInfo,
    client.GetConVar
local client_GetPlayerNameByIndex, client_GetPlayerNameByUserID, client_ChatTeamSay, client_AllowListener =
    client.GetPlayerNameByIndex,
    client.GetPlayerNameByUserID,
    client.ChatTeamSay,
    client.AllowListener
local globals_FrameTime,
    globals_AbsoluteFrameTime,
    globals_CurTime,
    globals_TickCount,
    globals_MaxClients,
    globals_RealTime,
    globals_FrameCount,
    globals_TickInterval =
    globals.FrameTime,
    globals.AbsoluteFrameTime,
    globals.CurTime,
    globals.TickCount,
    globals.MaxClients,
    globals.RealTime,
    globals.FrameCount,
    globals.TickInterval
local http_Get = http.Get
local math_ceil,
    math_tan,
    math_huge,
    math_log10,
    math_randomseed,
    math_cos,
    math_sinh,
    math_random,
    math_mod,
    math_pi,
    math_max,
    math_atan2,
    math_ldexp,
    math_floor,
    math_sqrt,
    math_deg,
    math_atan =
    math.ceil,
    math.tan,
    math.huge,
    math.log10,
    math.randomseed,
    math.cos,
    math.sinh,
    math.random,
    math.mod,
    math.pi,
    math.max,
    math.atan2,
    math.ldexp,
    math.floor,
    math.sqrt,
    math.deg,
    math.atan
local math_fmod,
    math_acos,
    math_pow,
    math_abs,
    math_min,
    math_log,
    math_frexp,
    math_sin,
    math_tanh,
    math_exp,
    math_modf,
    math_cosh,
    math_asin,
    math_rad =
    math.fmod,
    math.acos,
    math.pow,
    math.abs,
    math.min,
    math.log,
    math.frexp,
    math.sin,
    math.tanh,
    math.exp,
    math.modf,
    math.cosh,
    math.asin,
    math.rad
local table_foreach, table_sort, table_remove, table_foreachi, table_maxn, table_getn, table_concat, table_insert =
    table.foreach,
    table.sort,
    table.remove,
    table.foreachi,
    table.maxn,
    table.getn,
    table.concat,
    table.insert
local string_find,
    string_lower,
    string_format,
    string_rep,
    string_gsub,
    string_len,
    string_gmatch,
    string_dump,
    string_match,
    string_reverse,
    string_byte,
    string_char,
    string_upper,
    string_gfind,
    string_sub =
    string.find,
    string.lower,
    string.format,
    string.rep,
    string.gsub,
    string.len,
    string.gmatch,
    string.dump,
    string.match,
    string.reverse,
    string.byte,
    string.char,
    string.upper,
    string.gfind,
    string.sub
--endregion

--inspect
--@file check and download come from Chicken4676 https://aimware.net/forum/user/17687
local imagepack_lib_installed = false
file.Enumerate(
    function(filename)
        if filename == "imagepack_icons.lua" then
            imagepack_lib_installed = true
        end
    end
)
if not imagepack_lib_installed then
    http_Get(
        "https://raw.githubusercontent.com/287871/aimware/main/imagepack_icons.lua",
        function(ctx) --Network cache from Yukine
            file.Write("imagepack_icons.lua", ctx)
            network_error = ctx
        end
    )
end
--endregion

--region require
--@require come from Yukine https://aimware.net/forum/user/366321
local function require(filename)
    local res = file.Open(filename .. ".lua", "r")
    if res then
        local buf = res:Read()
        res:Close()
        return loadstring(buf)()
    end
    return nil
end

local function waiting_download()
    if not pcall(gui.GetValue, "misc.watermark") then
        if network_error == "error" then
            draw.Color(255, 0, 0, 255)
            draw.Text(0, 0, GetScriptName() .. "  Can't link to github")
        elseif not pcall(require, "imagepack_icons") then
            draw.Color(255, 255, 255, 255)
            draw.Text(0, 0, GetScriptName() .. "  Please wait to download the icon library")
        else
            draw.Color(34, 170, 74, 255)
            draw.Text(0, 0, GetScriptName() .. "  Download successfully, please reload")
        end
    end
    return
end
callbacks.Register("Draw", waiting_download)
local wpicon = require "imagepack_icons"
--endregion

--region gui
--- Reference
--- @aimware menu
--- @gui position
--- @ragebot accuracy weapon -acquisition of weapons
local menu = gui.Reference("menu")
local reference = gui.Reference("Misc", "General", "Extra")
local ragebot_accuracy_weapon = gui.Reference("Ragebot", "Accuracy", "Weapon")

--- Main switch
--- @watermark
--- @keybinds
--- @weapon_activeindicator
local watermark = gui.Checkbox(reference, "watermark", "Show Watermark", 1)
local keybinds = gui.Checkbox(reference, "keyingsind", "Show Keyings", 1)
local activeind = gui.Checkbox(reference, "weaponactiveind", "Weapon Activity Ind", 1)

--- @rgb effect switch
local watermark_rgb = gui.Checkbox(watermark, "rgb", "rgb", 0)
local keybinds_rgb = gui.Checkbox(keybinds, "rgb", "rgb", 0)
local activeind_rgb = gui.Checkbox(activeind, "rgb", "rgb", 0)

--- Colour
--- @watermark colour
local watermark_clr = gui.ColorPicker(watermark, "clr", "clr", 131, 109, 221, 255)
local watermark_clr2 = gui.ColorPicker(watermark, "clr2", "clr2", 255, 255, 255, 255)
local watermark_clr3 = gui.ColorPicker(watermark, "clr3", "clr3", 0, 0, 0, 100)

--- @keybinds colour
local keybinds_clr = gui.ColorPicker(keybinds, "clr", "clr", 131, 109, 221, 255)
local keybinds_clr2 = gui.ColorPicker(keybinds, "clr2", "clr2", 255, 255, 255, 255)
local keybinds_clr3 = gui.ColorPicker(keybinds, "clr3", "clr3", 0, 0, 0, 100)

--- @active weapon indicator colour
local activeind_clr = gui.ColorPicker(activeind, "clr", "clr", 131, 109, 221, 255)
local activeind_clr2 = gui.ColorPicker(activeind, "clr2", "clr2", 255, 255, 255, 255)
local activeind_clr3 = gui.ColorPicker(activeind, "clr3", "clr3", 0, 0, 0, 100)
local activeind_clr4 = gui.ColorPicker(activeind, "clr4", "clr4", 255, 255, 255, 255)

--- Position
local x, y = draw.GetScreenSize()
--- @watermark x y
local watermark_x = gui.Slider(watermark, "x", "x", 1900, 0, x)
local watermark_y = gui.Slider(watermark, "y", "y", 10, 0, y)

--- @keybinds x y
local keybinds_x = gui.Slider(keybinds, "x", "x", 300, 0, x)
local keybinds_y = gui.Slider(keybinds, "y", "y", 400, 0, y)

--- @active weapon x y
local activeind_x = gui.Slider(activeind, "x", "x", 450, 0, x)
local activeind_y = gui.Slider(activeind, "y", "y", 400, 0, y)

--- Settings gui parameter
--- @description
watermark:SetDescription("Shows watermark Aimware.net.")
keybinds:SetDescription("Displays the active binding key.")
activeind:SetDescription("Shows the hit rate and damage of the active weapon.")

--- @invisible
watermark_rgb:SetInvisible(true)
keybinds_rgb:SetInvisible(true)
activeind_rgb:SetInvisible(true)

watermark_x:SetInvisible(true)
watermark_y:SetInvisible(true)
keybinds_x:SetInvisible(true)
keybinds_y:SetInvisible(true)
activeind_x:SetInvisible(true)
activeind_y:SetInvisible(true)

local function gui_set_invisible()
    local watermark = watermark:GetValue()
    local keybinds = keybinds:GetValue()
    local activeind = activeind:GetValue()

    --- @watermark
    watermark_clr:SetInvisible(not watermark)
    watermark_clr2:SetInvisible(not watermark)
    watermark_clr3:SetInvisible(not watermark)

    --- @keybinds
    keybinds_clr:SetInvisible(not keybinds)
    keybinds_clr2:SetInvisible(not keybinds)
    keybinds_clr3:SetInvisible(not keybinds)
    --- @active weapon indicator
    activeind_clr:SetInvisible(not activeind)
    activeind_clr2:SetInvisible(not activeind)
    activeind_clr3:SetInvisible(not activeind)
    activeind_clr4:SetInvisible(not activeind)
end
--endregion

--region mouse drag
--- @check that the mouse is in range
local function is_inside(vec_x, vec_y, x, y, w, h)
    return vec_x >= x and vec_x <= w and vec_y >= y and vec_y <= h
end

--i don't know if there is a better function, so using this, you can save the location every time
--- @drag indicator position
local activeind_move_x, activeind_move_y, activeind_offset_x, activeind_offset_y, activeind_drag
local function drag_indicator(x, y, w, h)
    if not menu:IsActive() then
        return activeind_move_x, activeind_move_y
    end
    local mouse_down = input.IsButtonDown(1)
    if mouse_down then
        local mouse_x, mouse_y = input.GetMousePos()
        if not activeind_drag then
            local w, h = x + w, y + h
            if is_inside(mouse_x, mouse_y, x, y, w, h) then
                activeind_offset_x = mouse_x - x
                activeind_offset_y = mouse_y - y
                activeind_drag = true
            end
        else
            activeind_move_x = mouse_x - activeind_offset_x
            activeind_move_y = mouse_y - activeind_offset_y
            activeind_x:SetValue(activeind_move_x)
            activeind_y:SetValue(activeind_move_y)
        end
    else
        activeind_drag = false
    end
    return activeind_move_x, activeind_move_y
end

--- @drag indicator position 2
local keyingsind_offset_tx, keyingsind_offset_ty, keyingsind_offset_x, keyingsind_offset_y, _drag
local function drag_indicator2(x, y, w, h)
    if not menu:IsActive() then
        return keyingsind_offset_tx, keyingsind_offset_ty
    end
    local mouse_down = input.IsButtonDown(1)
    if mouse_down then
        local X, Y = input.GetMousePos()
        if not keyingsind_drag then
            local w, h = x + w, y + h
            if is_inside(X, Y, x, y, w, h) then
                keyingsind_offset_x, keyingsind_offset_y = X - x, Y - y
                keyingsind_drag = true
            end
        else
            keyingsind_offset_tx, keyingsind_offset_ty = X - keyingsind_offset_x, Y - keyingsind_offset_y
            keybinds_x:SetValue(keyingsind_offset_tx)
            keybinds_y:SetValue(keyingsind_offset_ty)
        end
    else
        keyingsind_drag = false
    end
    return keyingsind_offset_tx, keyingsind_offset_ty
end
--endregion

--region RGB gradient contrast effect
--- Come from https://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
--- a little modification made him work for lua
--- Converts an HSL color value to RGB. Conversion formula
--- adapted from http://en.wikipedia.org/wiki/HSL_color_space.
--- Assumes h, s, and l are contained in the set [0, 1] and
--- returns r, g, and b in the set [0, 255].
---
---@param   Number  h       The hue
---@param   Number  s       The saturation
---@param   Number  l       The lightness
---@return  Array           The RGB representation
local function hslToRgb(h, s, l)
    local r, g, b

    if (s == 0) then
        r = l
        g = l
        b = l -- achromatic
    else
        local function hue2rgb(p, q, t)
            if (t < 0) then
                t = t + 1
            end
            if (t > 1) then
                t = t - 1
            end
            if (t < 1 / 6) then
                return p + (q - p) * 6 * t
            end
            if (t < 1 / 2) then
                return q
            end
            if (t < 2 / 3) then
                return p + (q - p) * (2 / 3 - t) * 6
            end
            return p
        end

        local q = 0
        if (l < 0.5) then
            q = l * (1 + s)
        else
            q = l + s - l * s
        end

        local p = 2 * l - q

        r = hue2rgb(p, q, h + 1 / 3)
        g = hue2rgb(p, q, h)
        b = hue2rgb(p, q, h - 1 / 3)
    end

    return {r * 255, g * 255, b * 255}
end
--endregion

--region simple stop
local function clamp(val, min, max)
    if (val > max) then
        return max
    elseif (val < min) then
        return min
    else
        return val
    end
end
--endregion

--region rectangle
local renderer = {}

--- Rectangle
---@rectangle
renderer.rectangle = function(x, y, w, h, clr, fill, radius)
    local alpha = 255
    if clr[4] then
        alpha = clr[4]
    end
    draw.Color(clr[1], clr[2], clr[3], alpha)
    if fill then
        draw.FilledRect(x, y, x + w, y + h)
    else
        draw.OutlinedRect(x, y, x + w, y + h)
    end
    if fill == "s" then
        draw.ShadowRect(x, y, x + w, y + h, radius)
    end
end

---@gradient
renderer.gradient = function(x, y, w, h, clr, clr1, vertical)
    local r, g, b, a = clr1[1], clr1[2], clr1[3], clr1[4]
    local r1, g1, b1, a1 = clr[1], clr[2], clr[3], clr[4]

    if a and a1 == nil then
        a, a1 = 255, 255
    end

    if vertical then
        if clr[4] ~= 0 then
            if a1 and a ~= 255 then
                for i = 0, w do
                    renderer.rectangle(x, y + w - i, w, 1, {r1, g1, b1, i / w * a1}, true)
                end
            else
                renderer.rectangle(x, y, w, h, {r1, g1, b1, a1}, true)
            end
        end
        if a2 ~= 0 then
            for i = 0, h do
                renderer.rectangle(x, y + i, w, 1, {r, g, b, i / h * a}, true)
            end
        end
    else
        if clr[4] ~= 0 then
            if a1 and a ~= 255 then
                for i = 0, w do
                    renderer.rectangle(x + w - i, y, 1, h, {r1, g1, b1, i / w * a1}, true)
                end
            else
                renderer.rectangle(x, y, w, h, {r1, g1, b1, a1}, true)
            end
        end
        if a2 ~= 0 then
            for i = 0, w do
                renderer.rectangle(x + i, y, 1, h, {r, g, b, i / w * a}, true)
            end
        end
    end
end
--endregion

--region indicator position
---@position_save
local function position_save()
    if activeind_move_x ~= activeind_x:GetValue() or activeind_move_y ~= activeind_y:GetValue() then
        activeind_move_x = activeind_x:GetValue()
        activeind_move_y = activeind_y:GetValue()
    end
end
---@position_save2
local function position_save2()
    local x = keybinds_x:GetValue()
    local y = keybinds_y:GetValue()
    if keyingsind_offset_tx ~= x or keyingsind_offset_ty ~= y then
        keyingsind_offset_tx = x
        keyingsind_offset_ty = y
    end
end
---@active weapon indicator position
local function activeind_position()
    local x, y = drag_indicator(activeind_move_x, activeind_move_y, 150, 30)
    return x, y
end
--endregion

--region decoding svg
---@create texture
local function CreateTexture(svg)
    return draw.CreateTexture(common.RasterizeSVG(svg))
end
--endregion

--region weapon id
local weapon_id = {
    [1] = CreateTexture(wpicon["deagle"][3]),
    [2] = CreateTexture(wpicon["elite"][3]),
    [3] = CreateTexture(wpicon["fiveseven"][3]),
    [4] = CreateTexture(wpicon["glock"][3]),
    [7] = CreateTexture(wpicon["ak47"][3]),
    [8] = CreateTexture(wpicon["aug"][3]),
    [9] = CreateTexture(wpicon["awp"][3]),
    [10] = CreateTexture(wpicon["famas"][3]),
    [11] = CreateTexture(wpicon["g3sg1"][3]),
    [13] = CreateTexture(wpicon["galilar"][3]),
    [14] = CreateTexture(wpicon["m249"][3]),
    [16] = CreateTexture(wpicon["m4a1"][3]),
    [17] = CreateTexture(wpicon["mac10"][3]),
    [19] = CreateTexture(wpicon["p90"][3]),
    [23] = CreateTexture(wpicon["mp5sd"][3]),
    [24] = CreateTexture(wpicon["ump45"][3]),
    [25] = CreateTexture(wpicon["xm1014"][3]),
    [26] = CreateTexture(wpicon["bizon"][3]),
    [27] = CreateTexture(wpicon["mag7"][3]),
    [28] = CreateTexture(wpicon["negev"][3]),
    [29] = CreateTexture(wpicon["sawedoff"][3]),
    [30] = CreateTexture(wpicon["tec9"][3]),
    [31] = CreateTexture(wpicon["taser"][3]),
    [32] = CreateTexture(wpicon["hkp2000"][3]),
    [33] = CreateTexture(wpicon["mp7"][3]),
    [34] = CreateTexture(wpicon["mp9"][3]),
    [35] = CreateTexture(wpicon["nova"][3]),
    [36] = CreateTexture(wpicon["p250"][3]),
    [38] = CreateTexture(wpicon["scar20"][3]),
    [39] = CreateTexture(wpicon["sg556"][3]),
    [40] = CreateTexture(wpicon["ssg08"][3]),
    [41] = CreateTexture(wpicon["knifegg"][3]),
    [42] = CreateTexture(wpicon["knife"][3]),
    [43] = CreateTexture(wpicon["flashbang"][3]),
    [44] = CreateTexture(wpicon["hegrenade"][3]),
    [45] = CreateTexture(wpicon["smokegrenade"][3]),
    [46] = CreateTexture(wpicon["molotov"][3]),
    [47] = CreateTexture(wpicon["decoy"][3]),
    [48] = CreateTexture(wpicon["incgrenade"][3]),
    [49] = CreateTexture(wpicon["c4"][3]),
    [59] = CreateTexture(wpicon["knife"][3]),
    [60] = CreateTexture(wpicon["m4a1_silencer"][3]),
    [61] = CreateTexture(wpicon["usp_silencer"][3]),
    [63] = CreateTexture(wpicon["cz75a"][3]),
    [64] = CreateTexture(wpicon["revolver"][3]),
    [500] = CreateTexture(wpicon["bayonet"][3]),
    [505] = CreateTexture(wpicon["knife_flip"][3]),
    [506] = CreateTexture(wpicon["knife_gut"][3]),
    [507] = CreateTexture(wpicon["knife_karambit"][3]),
    [508] = CreateTexture(wpicon["knife_m9_bayonet"][3]),
    [509] = CreateTexture(wpicon["knife_tactical"][3]),
    [512] = CreateTexture(wpicon["knife_falchion"][3]),
    [514] = CreateTexture(wpicon["knife_bowie"][3]),
    [515] = CreateTexture(wpicon["knife_butterfly"][3]),
    [516] = CreateTexture(wpicon["knife_push"][3]),
    [519] = CreateTexture(wpicon["knife_ursus"][3]),
    [520] = CreateTexture(wpicon["knife_gypsy_jackknife"][3]),
    [522] = CreateTexture(wpicon["knife_stiletto"][3]),
    [523] = CreateTexture(wpicon["knife_widowmaker"][3]),
    [524] = CreateTexture(wpicon["knife_t"][3])
}
--endregion

--region weapon information
---@param entity
---@return Array
---@return [1] weapon name
---@return [2] weapon_ammo
---@return [3] weapon spare ammunition
---@return [4] weapon attack time
local function get_weapon_info(entity)
    local active_weapon = entity:GetPropEntity("m_hActiveWeapon")
    if not active_weapon:GetName() then
        return
    end
    local name = string_match(active_weapon:GetName(), [[weapon_(.+)]])
    local ammo = active_weapon:GetProp("m_iClip1")
    local ammo2 = active_weapon:GetProp("m_iPrimaryReserveAmmoCount")
    local attack = active_weapon:GetPropFloat("LocalActiveWeaponData", "m_flNextSecondaryAttack")
    return {name, ammo, ammo2, attack}
end
--endregion

--region aw menu current weapon
---@param reference
---@return aimware weapon variable name

local function menu_weapon(var)
    local wp = string_match(var, [["(.+)"]])
    local wp = string_lower(wp)
    if wp == "heavy pistol" then
        return "hpistol"
    elseif wp == "auto sniper" then
        return "asniper"
    elseif wp == "submachine gun" then
        return "smg"
    elseif wp == "light machine gun" then
        return "lmg"
    else
        return wp
    end
end
--endregion

---region weapon icon of active weapon indicator
---@param Number x  -Position
---@param Number y  -Position
---@param Number size   -Icon size
---@param Number size   -Icon size
---@param Array clr   -RGBA
local function weapon_icon(x, y, size, clr)
    local lp = entities_GetLocalPlayer()
    if not lp then
        return
    end
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]
    local wid = lp:GetWeaponID()
    local name = get_weapon_info(lp)[1]
    if name ~= nil then
        draw.Color(r, g, b, a)
        draw.SetTexture(weapon_id[wid])
        draw.FilledRect(x, y, x + wpicon[name][1] * size, y + wpicon[name][2] * size)
    end
    draw.SetTexture(nil)
end
--endregion

---region gradient and rilledRect
---@param Number x  -Position
---@param Number y  -Position
---@param Number w  -Width
---@param Array clr   -RGBA
---@param t or f rgb   -Enable or not
local function background(x, y, w, clr, _rgb)
    local gradient = renderer.gradient
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]
    local rgb = hslToRgb((globals_CurTime() / clamp(100 - 90, 1, 100)) % 1, 1, 0.5)
    draw.Color(r, g, b, a)
    draw.FilledRect(x, y, x + w, y + 2)
    if _rgb then
        gradient(x, y, w - 1, 2, {rgb[1], rgb[2], rgb[3], a}, {rgb[2], rgb[3], rgb[1], a}, false)
    end
end
--endregion

---region draw text shadow
---@param Number x  -Position
---@param Number y  -Position
---@param string    -string
---@param Array clr   -RGBA
local function text_shadow(x, y, string, clr)
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]
    draw.Color(4, 4, 4, a)
    draw.Text(x + 1, y + 1, string)
    draw.Color(r, g, b, a)
    draw.Text(x, y, string)
end
--endregion

---region time
local time, bTime, sTime = {0, 0, 0}, 0, 0
--- Split string
local function split_string(inputstr, sep)
    local t = {}
    for str in string_gmatch(inputstr, "([^" .. sep .. "]+)") do
        table_insert(t, str)
    end
    return t
end
--@Network cache from Yukine https://aimware.net/forum/user/366321
local function get_time_date()
    if time_date == nil then
        http_Get(
            "https://time.is/",
            function(time)
                time_date = time
            end
        )
    end
    return time_date
end
get_time_date()
--- Network access time
callbacks.Register(
    "Draw",
    "get_time",
    function()
        local lp = entities_GetLocalPlayer()
        if sTime == 0 or ((sTime + 1200 < common.Time()) and (lp == nil or not lp:IsAlive())) then
            if time_date ~= nil then
                for i, str in pairs(split_string(string_match(time_date, [[<time id="clock">(.-)</time>]]), ":")) do
                    time[i] = tonumber(str)
                end
                sTime = common.Time()
            end
            bTime = common.Time()
        end
        time[3] = time[3] + common.Time() - bTime
        bTime = common.Time()
        if time[3] >= 60 then
            time[2], time[3], bTime = time[2] + 1, 0, common.Time()
        end
        if time[2] >= 60 then
            time[1], time[2] = time[1] + 1, 0
        end
        if time[1] >= 24 then
            time[1] = 0
        end
    end
)
local time_date = nil
--return timt
---@return h    -hour
---@return m    -minute
---@return s    -second
local function get_timt()
    local time =
        string_format(
        "%s:%s:%s",
        time[1] < 10 and "0" .. math_floor(time[1]) or math_floor(time[1]),
        time[2] < 10 and "0" .. math_floor(time[2]) or math_floor(time[2]),
        time[3] < 10 and "0" .. math_floor(time[3]) or math_floor(time[3])
    )
    return time
end
--endregion

---region get server ip
---@param t or f
---@return localhost
---@return valve
---@return server ip
local function get_server_ip(object)
    if object then
        local server = engine.GetServerIP()
        if (server == "loopback") then
            return "localhost"
        elseif string_find(server, "A") then
            return "valve"
        else
            return server
        end
    end
end
--endregion

---region get delay
---@param entity
local function get_delay(entity)
    if entity then
        local pr = entities_GetPlayerResources()
        return pr:GetPropInt("m_iPing", entity:GetIndex())
    end
end
--endregion

---region get delay
---@param entity
local function get_name(localplayer)
    if localplayer then
        local lp_index = client_GetLocalPlayerIndex()
        local n = client_GetPlayerNameByIndex(lp_index)
        return n
    else
        local n = client_GetConVar("name")
        return n
    end
end
--endregion

---region text
local font = draw.CreateFont("Verdana", 12)
--- watermark
local tick = client_GetConVar("sv_maxcmdrate")
local function watermark_text(x, y, pattern)
    local divider = " | "
    local cheat = "aimware"
    local name = get_name(pattern)
    local time = get_timt()
    local text = cheat .. divider .. name

    if pattern then
        local delay = "delay:" .. get_delay(pattern) .. "ms"
        local ip = get_server_ip(pattern)
        local tick = tick .. "tick"
        text = text .. divider .. delay .. divider .. ip .. divider .. tick
    end
    local text = text .. divider .. time
    return text
end

--- keybinds
local keybinds_alpha = 0
local keybinds_alpha2 = 0
local keybinds_onshot_alpha = 0
local keybinds_doublefire_alpha = 0
local keybinds_slow_alpha = 0
local keybinds_fakecrouch_alpha = 0
local keybinds_lby_alpha = 0
local keybinds_trg_alpha = 0
local keybinds_speedburst_alpha = 0

local function keybinds_text(x, y, fade, var)
    local r, g, b, a = 255, 255, 255, 255
    local keybinds_y_i = 0
    local keybinds_x_i = 0
    local keybinds = keybinds:GetValue()
    draw.SetFont(font)

    ---region rbot function
    local rbot = gui.GetValue("rbot.master")

    --- Antiaim lby
    local lby = gui.GetValue("rbot.antiaim.base.lby")
    if rbot and var and lby < 0 then
        keybinds_lby_alpha = clamp(keybinds_lby_alpha + fade, 0, a)
    else
        keybinds_lby_alpha = clamp(keybinds_lby_alpha - fade, 0, a)
    end
    if keybinds_lby_alpha ~= 0 then
        keybinds_x_i = 20
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Anti-aim inverter", {r, g, b, keybinds_lby_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[toggled]", {r, g, b, keybinds_lby_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end

    --- Shift on shot
    local onshot = gui.GetValue("rbot.antiaim.condition.shiftonshot")
    if rbot and var and onshot then
        keybinds_onshot_alpha = clamp(keybinds_onshot_alpha + fade, 0, a)
    else
        keybinds_onshot_alpha = clamp(keybinds_onshot_alpha - fade, 0, a)
    end
    if keybinds_onshot_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Hide shots", {r, g, b, keybinds_onshot_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[toggled]", {r, g, b, keybinds_onshot_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end

    --- Double fire
    local wid = entities_GetLocalPlayer():GetWeaponID()
    local weapon = menu_weapon(ragebot_accuracy_weapon:GetValue())
    if
        rbot and var and
            (wid == 1 or wid == 2 or wid == 3 or wid == 4 or wid == 30 or wid == 32 or wid == 36 or wid == 61 or wid == 63 or wid == 7 or wid == 8 or
                wid == 10 or
                wid == 13 or
                wid == 16 or
                wid == 39 or
                wid == 60 or
                wid == 11 or
                wid == 38 or
                wid == 17 or
                wid == 19 or
                wid == 23 or
                wid == 24 or
                wid == 26 or
                wid == 33 or
                wid == 34 or
                wid == 14 or
                wid == 28 or
                wid == 25 or
                wid == 27 or
                wid == 29 or
                wid == 35) and
            gui.GetValue("rbot.hitscan.accuracy." .. weapon .. ".doublefire") > 0
     then
        keybinds_doublefire_alpha = clamp(keybinds_doublefire_alpha + fade, 0, a)
    else
        keybinds_doublefire_alpha = clamp(keybinds_doublefire_alpha - fade, 0, a)
    end
    if keybinds_doublefire_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Double fire", {r, g, b, keybinds_doublefire_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[toggled]", {r, g, b, keybinds_doublefire_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end

    --- Slow key
    local slow_key = gui.GetValue("rbot.accuracy.movement.slowkey")
    if rbot and var and slow_key ~= 0 and input.IsButtonDown(slow_key) then
        keybinds_slow_alpha = clamp(keybinds_slow_alpha + fade, 0, a)
    else
        keybinds_slow_alpha = clamp(keybinds_slow_alpha - fade, 0, a)
    end
    if keybinds_slow_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Slow walk", {r, g, b, keybinds_slow_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[holding]", {r, g, b, keybinds_slow_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end

    --- Fakecrouch key
    local fakecrouch_key = gui.GetValue("rbot.antiaim.extra.fakecrouchkey")
    if rbot and var and fakecrouch_key ~= 0 and input.IsButtonDown(fakecrouch_key) then
        keybinds_fakecrouch_alpha = clamp(keybinds_fakecrouch_alpha + fade, 0, a)
    else
        keybinds_fakecrouch_alpha = clamp(keybinds_fakecrouch_alpha - fade, 0, a)
    end
    if keybinds_fakecrouch_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Fake duck", {r, g, b, keybinds_fakecrouch_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[holding]", {r, g, b, keybinds_fakecrouch_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end
    --endregion

    ---region lbot function
    local lbot = gui.GetValue("lbot.master")

    --- Triggerbot
    local trg = gui.GetValue("lbot.trg.enable")
    local trg_key = gui.GetValue("lbot.trg.key")
    local trg_autofire = gui.GetValue("lbot.trg.autofire")
    if lbot and var and trg and trg_key ~= 0 and input.IsButtonDown(trg_key) then
        keybinds_trg_alpha = clamp(keybinds_trg_alpha + fade, 0, a)
    elseif lbot and trg and trg_autofire then
        keybinds_trg_alpha = clamp(keybinds_trg_alpha + fade, 0, a)
    else
        keybinds_trg_alpha = clamp(keybinds_trg_alpha - fade, 0, a)
    end
    if keybinds_trg_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Trigger", {r, g, b, keybinds_trg_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[holding]", {r, g, b, keybinds_trg_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end
    --endregion

    ---region misc function
    local misc = gui.GetValue("misc.master")
    --- Triggerbot
    local speedburst = gui.GetValue("misc.speedburst.enable")
    local speedburst_key = gui.GetValue("misc.speedburst.key")
    if misc and var and speedburst and speedburst_key ~= 0 and input.IsButtonDown(speedburst_key) then
        keybinds_speedburst_alpha = clamp(keybinds_speedburst_alpha + fade, 0, a)
    else
        keybinds_speedburst_alpha = clamp(keybinds_speedburst_alpha - fade, 0, a)
    end
    if keybinds_speedburst_alpha ~= 0 then
        text_shadow(x + 5, y + 25 + keybinds_y_i, "Speed burst", {r, g, b, keybinds_speedburst_alpha})
        text_shadow(x + 80 + keybinds_x_i, y + 25 + keybinds_y_i, "[holding]", {r, g, b, keybinds_speedburst_alpha})
        keybinds_y_i = keybinds_y_i + 15
    end
    --endregion
    return keybinds_x_i, keybinds_y_i
end

--- Active weapon text
local function active_weapon_text(x, y, clr)
    local weapon = menu_weapon(ragebot_accuracy_weapon:GetValue())
    local hitchance = gui.GetValue("rbot.hitscan.accuracy." .. weapon .. ".hitchance")
    local mindmg = gui.GetValue("rbot.hitscan.accuracy." .. weapon .. ".mindamage")
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]

    local hc_text = "HC " .. hitchance
    local dmg_text = "DMG " .. mindmg

    draw.SetFont(font)
    local weapon_text = "activity weapon"
    local text_x, text_y = draw.GetTextSize(weapon_text)
    text_shadow(x + text_x * 0.5 + 0.5, y + 5, weapon_text, {r, g, b, a})
    text_shadow(x + 100, y + 25, hc_text, {r, g, b, a})
    text_shadow(x + 100, y + 36, dmg_text, {r, g, b, a})
end
--endregion

---region on draw
--- On draw watermark
local function on_draw_watermark(alpha, pattern)
    draw.SetFont(font)
    local x, y = watermark_x:GetValue(), watermark_y:GetValue()
    local text = watermark_text(x, y, pattern)
    local w, h = draw.GetTextSize(text)
    local x = x - w

    local rgb = watermark_rgb:GetValue()
    local r, g, b, a = watermark_clr:GetValue()
    background(x, y, w + 10, {r, g, b, a * alpha / 255}, rgb)

    local r, g, b, a = watermark_clr3:GetValue()
    renderer.rectangle(x, y + 2, w + 10, 16, {r, g, b, a * alpha / 255}, true)

    local r, g, b, a = watermark_clr2:GetValue()
    draw.Color(r, g, b, a * alpha / 255)
    draw.Text(x + 5, y + 6, text)
    draw.Text(x + 5, y + 6, text)
end

--- On draw keybinds indicator
local function on_draw_keybinds()
    local fade_factor = ((1.0 / 0.15) * globals_FrameTime()) * 250
    local x, y = drag_indicator2(keyingsind_offset_tx, keyingsind_offset_ty, 120, 30)
    local keybinds = keybinds:GetValue()
    local lp = entities_GetLocalPlayer()

    local x_i, y_i = keybinds_text(x, y, fade_factor, lp:IsAlive() and keybinds)
    if lp:IsAlive() and keybinds and (y_i > 0 or menu:IsActive()) then
        keybinds_alpha = clamp(keybinds_alpha + fade_factor, 0, 255)
    else
        keybinds_alpha = clamp(keybinds_alpha - fade_factor, 0, 255)
    end
    if lp:IsAlive() and keybinds and x_i ~= 0 and keybinds then
        keybinds_alpha2 = clamp(keybinds_alpha2 + fade_factor, 0, 60)
    else
        keybinds_alpha2 = clamp(keybinds_alpha2 - fade_factor, 0, 60)
    end
    local r, g, b, a = keybinds_clr3:GetValue()
    if keybinds_alpha ~= 0 then
        renderer.rectangle(x, y + 2, 130 + keybinds_alpha2 * 0.3, 18, {r, g, b, keybinds_alpha * a / 255}, true)

        local r, g, b, a = keybinds_clr2:GetValue()
        text_shadow(x + 45 + (keybinds_alpha2 * 0.3 * 0.5), y + 5, "keybinds", {r, g, b, keybinds_alpha})

        local r, g, b, a = keybinds_clr:GetValue()
        local rgb = keybinds_rgb:GetValue()
        background(x, y, 129 + keybinds_alpha2 * 0.3, {r, g, b, keybinds_alpha * a / 255}, rgb)
    end
end

--- On draw active weapon indicator
local function on_draw_activeind(alpha)
    local x, y = activeind_position()

    local r, g, b, a = activeind_clr:GetValue()
    local rgb = activeind_rgb:GetValue()
    background(x, y, 150, {r, g, b, a * alpha / 255}, rgb)

    local r, g, b, a = activeind_clr3:GetValue()
    renderer.rectangle(x, y + 2, 150, 18, {r, g, b, a * alpha / 255}, true)

    local r, g, b, a = activeind_clr4:GetValue()
    weapon_icon(x + 5, y + 25, 0.6, {r, g, b, a * alpha / 255})

    local r, g, b, a = activeind_clr2:GetValue()
    active_weapon_text(x, y, {r, g, b, a * alpha / 255})
end
--endregion

---region callbacks
local activity_alpha = 0
local watermark_alpha = 0
local keybinds_alpha = 0
callbacks.Register(
    "Draw",
    function()
        gui_set_invisible()

        local fade_factor = ((1.0 / 0.15) * globals_FrameTime()) * 250
        local lp = entities_GetLocalPlayer()

        --- active weapon indicator
        if lp and lp:IsAlive() and activeind:GetValue() then
            activity_alpha = clamp(activity_alpha + fade_factor, 0, 255)
        else
            activity_alpha = clamp(activity_alpha - fade_factor, 0, 255)
        end
        if activity_alpha ~= 0 then
            position_save()
            on_draw_activeind(activity_alpha)
        end

        --- watermark
        if watermark:GetValue() then
            watermark_alpha = clamp(watermark_alpha + fade_factor, 0, 255)
        else
            watermark_alpha = clamp(watermark_alpha - fade_factor, 0, 255)
        end
        if watermark_alpha ~= 0 then
            on_draw_watermark(watermark_alpha, lp)
        end

        --- keybinds
        if lp and lp:IsAlive() and keybinds:GetValue() then
            keybinds_alpha = clamp(keybinds_alpha + fade_factor, 0, 255)
        else
            keybinds_alpha = clamp(keybinds_alpha - fade_factor, 0, 255)
        end
        if keybinds_alpha ~= 0 then
            position_save2()
            on_draw_keybinds()
        end
    end
)
--endregion





--***********************************************--

print("♥♥♥ " .. GetScriptName() .. " loaded without Errors ♥♥♥")

